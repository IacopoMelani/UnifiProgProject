package javamm;

@SuppressWarnings("all")
public class PalindromePair {
  public static int[][] palindromePair(int[] a) {
    int[][] matrix = new int[10000][2];
    int h = PalindromePair.findCouple(a, matrix);
    if ((h > 0)) {
      int[][] m = PalindromePair.reSizeMatrix(matrix, h);
      PalindromePair.sortMatrix(m);
      return m;
    } else {
      return new int[][] {};
    }
  }
  
  public static void sortMatrix(int[][] m) {
    int h = m.length;
    for (int i = 0; (i < h); i++) {
      for (int k = 1; (k < h); k++) {
        if (((m[i][0] > m[k][0]) || ((m[i][0] == m[k][0]) && (m[i][1] < m[k][1])))) {
          PalindromePair.swap(m, i, k);
        } else {
        }
      }
    }
  }
  
  public static void swap(int[][] m, int r1, int r2) {
    int tempxw = 0;
    int tempyz = 0;
    tempxw = m[r1][0];
    tempyz = m[r1][1];
    m[r1][0] = m[r2][0];
    m[r1][1] = m[r2][1];
    m[r2][0] = tempxw;
    m[r2][1] = tempyz;
  }
  
  public static int[][] reSizeMatrix(int[][] m, int k) {
    int[][] matrix = new int[k][2];
    for (int i = 0; (i < matrix.length); i++) {
      matrix[i] = m[i];
    }
    return matrix;
  }
  
  public static int contDigit(int n) {
    int cont = 0;
    while ((n != 0)) {
      {
        n = (n / 10);
        cont = (cont + 1);
      }
    }
    return cont;
  }
  
  public static int findCouple(int[] a, int[][] matrix) {
    int n = 0;
    int m = 0;
    int riga = 0;
    int h = 0;
    boolean c = false;
    for (n = 0; (n < a.length); n++) {
      for (m = 0; (m < a.length); m++) {
        {
          c = PalindromePair.checkCouple(a[n], a[m]);
          if ((Boolean.valueOf(c) == Boolean.valueOf(true))) {
            if ((n > m)) {
              matrix[riga][0] = m;
              matrix[riga][1] = n;
            } else {
              matrix[riga][0] = n;
              matrix[riga][1] = m;
            }
            riga = (riga + 1);
            h = (h + 1);
          }
        }
      }
    }
    return h;
  }
  
  public static boolean checkCouple(int n, int m) {
    boolean c = true;
    int digitM = PalindromePair.contDigit(m);
    int _powOfX = PalindromePair.powOfX(digitM, 10);
    int _multiply = (n * _powOfX);
    n = _multiply;
    n = (n + m);
    int[] a = PalindromePair.putNInArray(n);
    int[] b = PalindromePair.reverseArray(a);
    c = PalindromePair.palindrome(b);
    return c;
  }
  
  public static int powOfX(int n, int x) {
    int ris = x;
    for (int i = 1; (i < n); i++) {
      ris = (ris * x);
    }
    return ris;
  }
  
  public static int[] putNInArray(int n) {
    int[] a = new int[PalindromePair.contDigit(n)];
    int i = 0;
    int r = 0;
    while ((n != 0)) {
      {
        r = (n % 10);
        a[i] = r;
        i = (i + 1);
        n = (n / 10);
      }
    }
    return a;
  }
  
  public static int[] reverseArray(int[] a) {
    int[] b = new int[a.length];
    int _length = a.length;
    int j = (_length - 1);
    for (int i = 0; (i < b.length); i++) {
      {
        b[i] = a[j];
        j = (j - 1);
      }
    }
    return b;
  }
  
  public static boolean palindrome(int[] a) {
    int len = a.length;
    int top = (len - 1);
    for (int down = 0; (down < len); down++) {
      {
        boolean _tripleNotEquals = (a[down] != a[top]);
        if (_tripleNotEquals) {
          return false;
        }
        top--;
      }
    }
    return true;
  }
  
  public static void main(String[] args) {
    int[] a = { 111, 33211, 1943449, 1 };
    int[][] c = PalindromePair.palindromePair(a);
    System.out.println();
  }
}
